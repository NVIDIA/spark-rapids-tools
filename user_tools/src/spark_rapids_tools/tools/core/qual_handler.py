# Copyright (c) 2025, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
QualCoreHandler class for handling qualification core tool results.

This class serves as the main entry point for analyzing qualification output,
providing high-level methods to access and manipulate the results.
"""

from dataclasses import dataclass, field
from logging import Logger
from pathlib import Path
from typing import List, Dict, Any

import pandas as pd

from spark_rapids_pytools.common.sys_storage import FSUtil
from spark_rapids_pytools.common.utilities import Utils
from spark_rapids_tools import CspPathT
from spark_rapids_tools.tools.core.qual_table_loader import QualCoreTableLoader
from spark_rapids_tools.tools.core.qual_output_reader import QualOutputFileReader


@dataclass
class QualCoreHandler:
    """Handles the results generated by a qualification core tool run"""

    result_path: CspPathT
    qual_core_tbl_mgr: QualCoreTableLoader = field(default=None, init=False)
    qual_output_reader: QualOutputFileReader = field(default=None, init=False)
    logger: Logger = field(default=None, init=False)

    def __post_init__(self):
        """Initialize the qualification core handler components."""
        self.qual_core_tbl_mgr = QualCoreTableLoader()
        self.qual_output_reader = QualOutputFileReader(str(self.result_path))
        self.logger = Utils.get_logger(self.__class__.__name__)

    def is_empty_result(self) -> bool:
        """Check if the result path exists and contains qualification output."""
        if not self.result_path.exists():
            return True

        # Check if qual_core_output directory exists
        qual_core_path = FSUtil.build_path(str(self.result_path), 'qual_core_output')
        return not Path(qual_core_path).exists()

    def get_table_by_label(self, label: str, file_format: str = 'csv') -> pd.DataFrame:
        """
        Get a qualification table by its label.

        Args:
            label: The table label from the YAML configuration
            file_format: File format to read ('csv' or 'json')

        Returns:
            DataFrame containing the table data
        """
        try:
            return self.qual_output_reader.read_table_by_label(label, file_format)
        except Exception as e:
            self.logger.error(f"Failed to read table with label '{label}': {e}")
            return pd.DataFrame()

    def get_global_tables(self) -> List[pd.DataFrame]:
        """
        Get all global scope tables.

        Returns:
            List of DataFrames for all global scope tables
        """
        global_tables = self.qual_core_tbl_mgr.get_tables_by_scope('global')
        results = []

        for table_def in global_tables:
            try:
                df = self.qual_output_reader.read_table_by_label(
                    table_def.label,
                    table_def.file_format or 'csv'
                )
                results.append(df)
            except Exception as e:
                self.logger.warning(f"Failed to read global table '{table_def.label}': {e}")
                results.append(pd.DataFrame())

        return results

    def get_per_app_tables(self) -> List[pd.DataFrame]:
        """
        Get all per-app scope tables (combined across all applications).

        Returns:
            List of DataFrames for all per-app scope tables
        """
        per_app_tables = self.qual_core_tbl_mgr.get_tables_by_scope('per-app')
        results = []

        for table_def in per_app_tables:
            try:
                df = self.qual_output_reader.read_table_by_label(
                    table_def.label,
                    table_def.file_format or 'csv'
                )
                results.append(df)
            except Exception as e:
                self.logger.warning(f"Failed to read per-app table '{table_def.label}': {e}")
                results.append(pd.DataFrame())

        return results

    def get_available_table_labels(self) -> List[str]:
        """
        Get all available table labels that can be read.

        Returns:
            List of available table labels
        """
        try:
            return self.qual_output_reader.list_available_tables()
        except Exception as e:
            self.logger.error(f"Failed to list available tables: {e}")
            return []

    def get_table_definitions(self) -> List[Any]:
        """
        Get all table definitions from the YAML configuration.

        Returns:
            List of QualCoreTableDef objects
        """
        try:
            return self.qual_core_tbl_mgr.load_table_definitions()
        except Exception as e:
            self.logger.error(f"Failed to load table definitions: {e}")
            return []

    def get_summary_info(self) -> Dict[str, Any]:
        """
        Get summary information about the qualification results.

        Returns:
            Dictionary containing summary information
        """
        summary = {
            'result_path': str(self.result_path),
            'result_exists': self.result_path.exists(),
            'is_empty': self.is_empty_result(),
            'available_tables': self.get_available_table_labels()
        }

        if not summary['is_empty']:
            try:
                table_defs = self.get_table_definitions()
                summary['global_tables'] = [t.label for t in table_defs if t.scope == 'global']
                summary['per_app_tables'] = [t.label for t in table_defs if t.scope == 'per-app']
            except Exception as e:
                self.logger.warning(f"Failed to get table summary: {e}")
                summary['global_tables'] = []
                summary['per_app_tables'] = []

        return summary
