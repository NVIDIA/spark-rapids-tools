# Copyright (c) 2025, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
QualCoreHandler class for handling qualification core tool results.

This class serves as the main entry point for analyzing qualification output,
providing high-level methods to access and manipulate the results.
"""

from dataclasses import dataclass, field
from logging import Logger
from pathlib import Path
from typing import List, Dict, Any, Union, Optional

import pandas as pd

from spark_rapids_pytools.common.sys_storage import FSUtil
from spark_rapids_pytools.common.utilities import ToolLogging
from spark_rapids_tools import CspPathT
from spark_rapids_tools.tools.core.qual_table_loader import QualCoreTableLoader
from spark_rapids_tools.tools.core.qual_output_reader import QualOutputFileReader


@dataclass
class QualCoreHandler:
    """Handles the results generated by a qualification core tool run"""

    result_path: Union[str, CspPathT]
    qual_core_tbl_mgr: QualCoreTableLoader = field(default=None, init=False)
    qual_output_reader: QualOutputFileReader = field(default=None, init=False)
    logger: Logger = field(default=None, init=False)

    def __post_init__(self):
        """Initialize the qualification core handler components."""
        self.qual_core_tbl_mgr = QualCoreTableLoader()
        self.qual_output_reader = QualOutputFileReader(self.result_path)
        self.logger = ToolLogging.get_and_setup_logger(self.__class__.__name__)

    def is_empty_result(self) -> bool:
        """Check if the result path exists and contains qualification output."""
        if isinstance(self.result_path, str):
            if not Path(self.result_path).exists():
                return True
        else:
            if not self.result_path.exists():
                return True

        qual_core_path = FSUtil.build_path(self.result_path, 'qual_core_output')
        return not Path(qual_core_path).exists()

    def get_table_by_label(self,
                           label: str,
                           file_format: str = 'csv',
                           read_csv_kwargs: Optional[dict] = None) -> pd.DataFrame:
        """Get a qualification table by its label."""
        try:
            return self.qual_output_reader.read_table_by_label(label, file_format, read_csv_kwargs)
        except Exception as e:  # pylint: disable=broad-except
            self.logger.error('Failed to read table with label \'%s\': %s', label, e)
            return pd.DataFrame()

    def get_global_tables(self) -> List[pd.DataFrame]:
        """Get all global scope tables."""
        global_tables = self.qual_core_tbl_mgr.get_tables_by_scope('global')
        results = []

        for table_def in global_tables:
            try:
                df = self.qual_output_reader.read_table_by_label(
                    table_def.label,
                    table_def.file_format or 'csv'
                )
                results.append(df)
            except Exception as e:  # pylint: disable=broad-except
                self.logger.warning('Failed to read global table \'%s\': %s', table_def.label, e)
                results.append(pd.DataFrame())

        return results

    def get_per_app_tables(self) -> List[pd.DataFrame]:
        """Get all per-app scope tables (combined across all applications)."""
        per_app_tables = self.qual_core_tbl_mgr.get_tables_by_scope('per-app')
        results = []

        for table_def in per_app_tables:
            try:
                df = self.qual_output_reader.read_table_by_label(
                    table_def.label,
                    table_def.file_format or 'csv'
                )
                results.append(df)
            except Exception as e:  # pylint: disable=broad-except
                self.logger.warning('Failed to read per-app table \'%s\': %s', table_def.label, e)
                results.append(pd.DataFrame())

        return results

    def get_table_definitions(self) -> List[Any]:
        """Get all table definitions from the YAML configuration."""
        try:
            return self.qual_core_tbl_mgr.load_table_definitions()
        except Exception as e:  # pylint: disable=broad-except
            self.logger.error('Failed to load table definitions: %s', e)
            return []

    def get_raw_metrics_paths(self) -> List[str]:
        """Get paths to raw_metrics directories.
        This is used in qualx to read raw_metrics by first getting the path to the
        raw_metrics directory and then read the files.
        TODO: Find usages and update to read files using QualCoreHandler"""
        try:
            qual_core_path = FSUtil.build_path(self.result_path, 'qual_core_output')
            if not Path(qual_core_path).exists():
                return []

            raw_metrics_path = FSUtil.build_path(qual_core_path, 'raw_metrics')
            if Path(raw_metrics_path).exists() and Path(raw_metrics_path).is_dir():
                return [raw_metrics_path]

            return []
        except Exception as e:  # pylint: disable=broad-except
            self.logger.error('Failed to get raw_metrics paths: %s', e)
            return []

    def get_raw_metric_per_app_dict(self,
                                    file_name: str,
                                    read_csv_kwargs: Optional[dict] = None) -> Dict[str, pd.DataFrame]:
        """Read a specific raw metric file from each application's directory and return as a dictionary
        of application IDs and DataFrames containing the corresponding application's metrics data.
        TODO: Remove this method once we have fully migrated to the qual handler.
        This method mimics the behavior of _read_qualification_metric_file by reading the specified
        file from each application's directory under raw_metrics."""
        try:
            metrics = self.qual_output_reader.read_raw_metric_per_app_files(file_name, read_csv_kwargs)
            # Log apps with missing metrics files
            apps_with_missing_metrics = [app_id for app_id, df in metrics.items() if df.empty]
            if apps_with_missing_metrics:
                self.logger.warning('Unable to read metrics file \'%s\' for apps: %s', file_name,
                                    ', '.join(apps_with_missing_metrics))

            return metrics
        except Exception as e:  # pylint: disable=broad-except
            self.logger.error('Failed to read raw metric per-app files \'%s\': %s', file_name, e)
            return {}
