# Copyright (c) 2025, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Module that contains the implementation on reading and extracting information from a report
generated by the tools wrapper/core."""

from collections import defaultdict
from dataclasses import dataclass, field
from functools import partial
from typing import Dict, Optional, List, Callable, Union, TypeVar, Type

import pandas as pd
from spark_rapids_tools import override
from spark_rapids_tools.api_v1 import AppHandler
from spark_rapids_tools.api_v1.table_definition import TableDef
from spark_rapids_tools.enums import ReportTableFormat
from spark_rapids_tools.storagelib.cspfs import BoundedCspPath
from spark_rapids_tools.utils.data_utils import LoadDFResult, DataUtils, JPropsResult, TXTResult, JSONResult


@dataclass
class ToolReportReader(object):
    """
    A class that executes the actual consumption of an output report.
    :param out_path: The path to the report output.
    :param report_id: The report identifier, which is used to identify the report.
    :param table_definitions: A dictionary of table definitions that are used to define the tables
                                in the report.
    :param app_fds: A dictionary of AppHandler objects that represent the applications in the report.
    """
    out_path: BoundedCspPath
    report_id: str
    table_definitions: Dict[str, TableDef] = field(default_factory=dict)
    app_fds: Dict[str, AppHandler] = field(default_factory=dict)

    def _load_app_fds(self) -> None:
        """
        Self constructor to initialize the list of app handlers for a reader.
        """

    def resolve_app_fds(self) -> None:
        """
        Resolve the application file descriptors (app_fds) by loading them from the report.
        This method should be overridden in subclasses to provide specific implementation.
        """

    def set_apps(self, defined_apps: Dict[str, AppHandler]) -> None:
        self.app_fds.update(defined_apps)

    def is_per_app(self) -> bool:
        """
        Check if this reader is designed to handle reports per application.
        :return: True if it is a per-app reader, False otherwise.
        """
        return False

    #################
    # Public APIs
    #################
    def app_fds_empty(self) -> bool:
        """
        Check if the app_fds dictionary is empty.
        :return: true/false
        """
        return len(self.app_fds) == 0

    def out_path_exists(self) -> bool:
        """
        Check if the output path exists.
        """
        return self.out_path.exists()

    def get_table(self, tbl_lbl: str) -> Optional[TableDef]:
        """
        Get a table definition by its label.
        :param tbl_lbl: the label identifier of the table.
        :return: the object representing the table.
        """
        return self.table_definitions.get(tbl_lbl)

    def get_table_path(self, tbl_lbl: str) -> BoundedCspPath:
        """
        Get the path to the table file based on its label.
        :param tbl_lbl: The label of the table.
        :return: The path to the table file.
        :raises ValueError: If the table with the given label is not found.
        """
        table_def = self.get_table(tbl_lbl)
        if not table_def:
            raise ValueError(f'Table with label {tbl_lbl} not found.')
        return self.out_path.create_sub_path(table_def.file_name)

    def list_all_tables(self) -> List[TableDef]:
        """
        List all table definitions available in this report reader.
        :return: A list of TableDef objects.
        """
        return list(self.table_definitions.values())

    @staticmethod
    def _append_tbl_schema(table_def: TableDef,
                           pd_kwargs: Optional[dict] = None) -> dict:
        """
        Append the table schema to the provided pandas kwargs.
        This is useful to ensure that the DataFrame created from the table
        has the correct schema based on the table definition.
        :param table_def: table definition object that contains the schema
        :param pd_kwargs: the arguments sent by the caller to the pandas DataFrame constructor.
                             If None, an empty dictionary will be used.
        :return: A dictionary with the updated pandas kwargs that includes the schema
                 based on the table definition.
        """
        if pd_kwargs is None:
            pd_kwargs = {}
        if pd_kwargs and 'dtype' in pd_kwargs:
            # If dtype is already set, we should not override it.
            return pd_kwargs
        pd_kwargs.update({'dtype': table_def.convert_to_schema()})
        return pd_kwargs

    @staticmethod
    def _validate_tbl_format(tbl: TableDef,
                             req_format: ReportTableFormat) -> None:
        """
        Validate that the table format is supported.
        :param tbl: The table label or TableDef object.
        :param req_format: The required format for the table.
        :raises ValueError: If the table format is not supported.
        """
        if not tbl.accepts(req_format):
            raise ValueError(f'Table {tbl.label} does not support format {req_format}. '
                             f'Available formats: {tbl.file_format}.')

    def _process_tbl_arg(self,
                         tbl: Union[str, TableDef],
                         req_format: ReportTableFormat) -> Optional[TableDef]:
        """
        Process the table arguments to ensure they are in the correct format.
        :param tbl: tbl can be either a string (table label) or a TableDef object.
        :return: the table if it ios a valid one.
        """
        table_def = self._normalize_tbl(tbl)
        self._validate_tbl_format(table_def, req_format)
        return table_def

    def _normalize_tbl(self, tbl: Union[str, TableDef]) -> TableDef:
        """
        Normalize the table definition to ensure it is a TableDef object.
        :param tbl: The table label or TableDef object.
        :return: A TableDef object.
        """
        if isinstance(tbl, str):
            # throw ValueError if the table is not found
            if tbl not in self.table_definitions:
                raise ValueError(f'Table {tbl} not found in report {self.report_id}.')
            return self.get_table(tbl)
        return tbl

    def _get_tbl_file(self, tbl: TableDef):
        """
        Get the file path for the given table definition.
        :param tbl: The table definition object.
        :return: The file path for the table.
        """
        return self.out_path.create_sub_path(tbl.file_name)

    #########################
    # Public API to load data
    #########################

    def is_empty_result(self) -> bool:
        """
        Check if the report is empty. This is done by checking if the output path exists and
        if the app_fds dictionary is empty.
        :return: True if the report is empty, False otherwise.
        """
        if not self.out_path.exists():
            return True
        return self.app_fds_empty()

    def load_df(self,
                tbl: str,
                fall_cb: Optional[Callable[[], pd.DataFrame]] = None,
                map_cols: Optional[dict] = None,
                pd_args: Optional[dict] = None) -> LoadDFResult:
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.CSV)
        return DataUtils.load_pd_df(self._get_tbl_file(table_def),
                                    default_cb=fall_cb,
                                    map_columns=map_cols,
                                    read_csv_kwargs=self._append_tbl_schema(table_def, pd_args))

    def load_jprop(self,
                   tbl: str) -> JPropsResult:
        """
        Load a DataFrame for a specific table in the report.
        :param tbl: The label of the table to load.
        :return: The loaded DataFrame result.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.PROPERTIES)
        return DataUtils.load_jprops(self._get_tbl_file(table_def))

    def load_txt(self, tbl: str) -> TXTResult:
        """
        Load a text file for a specific table in the report.
        :param tbl:
        :return:
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.TXT)
        return DataUtils.load_txt(self._get_tbl_file(table_def))

    def load_json(self, tbl: str) -> JSONResult:
        """
        Load a JSON file for a specific table in the report.
        :param tbl: The label of the table to load.
        :return: The loaded JSONResult result.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.JSON)
        return DataUtils.load_json(self._get_tbl_file(table_def))

    def apps_count(self) -> int:
        """
        Get the count of applications in the report.
        :return: The number of applications.
        """
        return len(self.app_fds)


@dataclass
class PerAppToolReportReader(ToolReportReader):
    """
    Similar to the Parent class but this will have the ability to consume reports
    per application. It has some other features that can be used as utility.
    """
    @override
    def is_per_app(self) -> bool:
        """
        Check if this reader is designed to handle reports per application.
        :return: True if it is a per-app reader, False otherwise.
        """
        return True

    def _get_app_tbl_file(self, tbl: TableDef, app_id: str) -> BoundedCspPath:
        """
        Get the file path for the given table definition.
        :param tbl: The table definition object.
        :param app_id: The application ID for which the table file is being requested.
        :return: The file path for the table.
        """
        return self.out_path.create_sub_path(f'{app_id}/{tbl.file_name}')

    def _resolve_app_id(self, app_arg: Union[str, AppHandler]) -> str:
        """
        Resolve a single application ID from the app_fds dictionary or the argument passed to the
        report builder.
        :param app_arg: The application ID or AppHandler object.
        :return: The resolved application ID.
        """
        if isinstance(app_arg, str):
            app_id = app_arg
        else:
            app_id = app_arg.uuid
        # check that the app_id exists in the valid app_fds
        if app_id not in self.app_fds:
            raise ValueError(f'Application [{app_id}] not found in report [{self.report_id}].')
        return app_id

    def _resolve_app_ids(self,
                         app_args: Optional[List[Union[str, AppHandler]]] = None) -> List[str]:
        """
        Resolve the application IDs from the app_fds dictionary or the arguments passed to the
        report builder.
        :param app_args: Optional list of application IDs or AppHandler objects.
        :return: A list of resolved application IDs.
        """
        res = []
        if app_args is None or len(app_args) == 0:
            return [app_h.uuid for app_h in self.app_fds.values()]
        for app_arg in app_args:
            app_id = self._resolve_app_id(app_arg)
            res.append(app_id)
        return res

    def __build_csv_load_args(
            self,
            tbl_def: TableDef,
            fall_cb: Optional[Callable[[], pd.DataFrame]] = None,
            map_cols: Optional[dict] = None,
            pd_args: Optional[dict] = None) -> (partial, dict):
        """
        Helper method to build the load function and its arguments based on the table definition.
        This is useful to avoid code duplication between load_app_df and load_apps_df methods.
        :return: a tuple of (load_function, load_arguments) where load_function is a partial function
                    that can be called to load the DataFrame and load_arguments is a dictionary of
                    arguments to be passed to the load_function.
        """
        load_args = {
            'default_cb': fall_cb,
            'map_columns': map_cols
        }
        if tbl_def.file_format == ReportTableFormat.JSON:
            # JSON files do not support dtype argument in pandas read_json
            # we need to call a JSON to Pandas converter to normalize the fields.
            load_df_func = partial(DataUtils.load_pd_df_from_json)
        else:
            load_df_func = partial(DataUtils.load_pd_df)
            load_args['read_csv_kwargs'] = self._append_tbl_schema(tbl_def, pd_args)
        return load_df_func, load_args

    def load_apps_df(self,
                     tbl: str,
                     apps: Optional[List[Union[str, AppHandler]]] = None,
                     fall_cb: Optional[Callable[[], pd.DataFrame]] = None,
                     map_cols: Optional[dict] = None,
                     pd_args: Optional[dict] = None) -> Dict[str, LoadDFResult]:
        """
        Load DataFrames for multiple applications from the report.

        :param tbl: The label of the table to load.
        :param apps: Optional list of application IDs or AppHandler objects.
                     If not provided, all applications in the report will be used.
        :param fall_cb: Optional callback to provide a fallback DataFrame if loading fails.
        :param map_cols: Optional dictionary to map column names.
        :param pd_args: Optional dictionary of arguments to pass to the pandas DataFrame constructor.
        :return: A dictionary mapping application IDs to their corresponding LoadDFResult.
        :raises ValueError: If the table or any application is not found in the report.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.CSV)
        res: Dict[str, LoadDFResult] = {}
        app_ids = self._resolve_app_ids(app_args=apps)
        load_df_func, load_args = self.__build_csv_load_args(table_def, fall_cb, map_cols, pd_args)
        for app_id in app_ids:
            app_res = load_df_func(
                self._get_app_tbl_file(table_def, app_id),
                **load_args
            )
            res[app_id] = app_res
        return res

    def load_app_df(self,
                    tbl: str,
                    app: Union[str, AppHandler],
                    fall_cb: Optional[Callable[[], pd.DataFrame]] = None,
                    map_cols: Optional[dict] = None,
                    pd_args: Optional[dict] = None) -> LoadDFResult:
        """
        Load a DataFrame for a specific application from the report.

        :param tbl: The label of the table to load.
        :param app: The application ID or AppHandler object for which to load the table.
        :param fall_cb: Optional callback to provide a fallback DataFrame if loading fails.
        :param map_cols: Optional dictionary to map column names.
        :param pd_args: Optional dictionary of arguments to pass to the pandas DataFrame constructor.
        :return: The loaded DataFrame result for the specified application and table.
        :raises ValueError: If the table or application is not found in the report.
        """
        try:
            table_def = self._process_tbl_arg(tbl, ReportTableFormat.CSV)
            app_id = self._resolve_app_id(app_arg=app)
            load_df_func, load_args = self.__build_csv_load_args(table_def, fall_cb, map_cols, pd_args)
            return load_df_func(
                self._get_app_tbl_file(table_def, app_id),
                **load_args
            )
        except Exception as e:  # pylint: disable=broad-except
            # this could mean that appId is not in this resultHandler
            loaded_df = None
            invalid_app_id = 'UNKNOWN_APP_ID'
            if isinstance(app, str):
                invalid_app_id = app
            fallen_back = False
            if fall_cb is not None:
                loaded_df = fall_cb()
                fallen_back = True
            return LoadDFResult(
                f_path=str(self.out_path.create_sub_path(f'{invalid_app_id}/{tbl}')),
                data=loaded_df,
                success=False,
                fallen_back=fallen_back,
                load_error=e
            )

    def load_apps_jprop(self,
                        tbl: str,
                        apps: Optional[List[Union[str, AppHandler]]] = None) -> Dict[str, JPropsResult]:
        """
        Load a Java properties for a specific table in the report.
        :param tbl: The label of the table to load.
        :param apps: Optional list of application IDs or AppHandler objects.
                     If not provided, all applications in the report will be used.
        :raises ValueError: If the table or application is not found in the report.
        :return: The loaded JPropsResult result.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.PROPERTIES)
        res: Dict[str, JPropsResult] = {}
        app_ids = self._resolve_app_ids(app_args=apps)
        for app_id in app_ids:
            res[app_id] = DataUtils.load_jprops(self._get_app_tbl_file(table_def, app_id))
        return res

    def load_app_jprop(self,
                       tbl: str,
                       app: Union[str, AppHandler]) -> JPropsResult:
        """
        Load a Java properties for a specific table in the report.
        :param tbl: The label of the table to load.
        :param app: Optional list of application IDs or AppHandler objects.
                     If not provided, all applications in the report will be used.
        :raises ValueError: If the table or application is not found in the report.
        :return: The loaded JPropsResult result.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.PROPERTIES)
        app_id = self._resolve_app_id(app_arg=app)
        return DataUtils.load_jprops(self._get_app_tbl_file(table_def, app_id))

    def load_apps_txt(self,
                      tbl: str,
                      apps: Optional[List[Union[str, AppHandler]]] = None) -> Dict[str, TXTResult]:
        """
        Load a text file for a specific table in the report.
        :param tbl: The label of the table to load.
        :param apps: Optional list of application IDs or AppHandler objects.
                     If not provided, all applications in the report will be used.
        :return: A dictionary mapping application IDs to their corresponding TXTResult.
        """
        res: Dict[str, TXTResult] = {}
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.TXT)

        app_ids = self._resolve_app_ids(app_args=apps)
        for app_id in app_ids:
            res[app_id] = DataUtils.load_txt(self._get_app_tbl_file(table_def, app_id))
        return res

    def load_app_txt(self,
                     tbl: str,
                     app: Optional[AppHandler] = None) -> TXTResult:
        """
        Load a text file for a specific table in the report.
        :param tbl: The label of the table to load.
        :param app: Optional application ID or AppHandler object.
                     If not provided, all applications in the report will be used.
        :raises ValueError: If the application is not found in the report.
        :return: The loaded TXTResult result for the specified application and table.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.TXT)
        app_id = self._resolve_app_id(app_arg=app)
        return DataUtils.load_txt(self._get_app_tbl_file(table_def, app_id))

    def load_apps_json(self,
                       tbl: str,
                       apps: Optional[List[Union[str, AppHandler]]] = None) -> Dict[str, JSONResult]:
        """
        Load a JSON file for a specific table in the report.
        :param tbl: The label of the table to load.
        :param apps: Optional list of application IDs or AppHandler objects.
                     If not provided, all applications in the report will be used.
        :return: A dictionary mapping application IDs to their corresponding JSONResult.
        """
        res: Dict[str, JSONResult] = {}
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.JSON)

        app_ids = self._resolve_app_ids(app_args=apps)
        for app_id in app_ids:
            res[app_id] = DataUtils.load_json(self._get_app_tbl_file(table_def, app_id))
        return res

    def load_app_json(self,
                      tbl: str,
                      app: Optional[AppHandler] = None) -> JSONResult:
        """
        Load a JSON file for a specific table in the report.
        :param tbl: The label of the table to load.
        :param app: Optional application ID or AppHandler object.
                     If not provided, all applications in the report will be used.
        :raises ValueError: If the application is not found in the report.
        :return: The loaded JSONResult result for the specified application and table.
        """
        table_def = self._process_tbl_arg(tbl, ReportTableFormat.JSON)
        app_id = self._resolve_app_id(app_arg=app)
        return DataUtils.load_json(self._get_app_tbl_file(table_def, app_id))

#########################
# Type Definitions
#########################


ToolReportReaderT = TypeVar('ToolReportReaderT', bound=ToolReportReader)

report_registry: Dict[str, Type[ToolReportReaderT]] = defaultdict(lambda: PerAppToolReportReader)


def register_report_class(key: str):
    """
    A decorator to register dataclasses with a custom key.
    """
    def decorator(cls: Type[ToolReportReaderT]) -> Type[ToolReportReaderT]:
        report_registry[key] = cls
        return cls
    return decorator
